/**
 * Integration test: fetches the live sitemap and verifies every doc URL
 * returns valid markdown via Accept: text/markdown header.
 *
 * Set TEST_ENV=staging or TEST_ENV=production to test a single environment.
 * When unset, tests both.
 *
 * Note: The production sitemap is always used as the URL source because
 * staging has noIndex enabled which suppresses sitemap generation. URLs
 * are rewritten to the target environment's base path.
 *
 * Run with: yarn test:integration
 * Requires network access to www.marketdata.app
 */
import { describe, it, expect } from 'vitest';

const PROD_SITEMAP_URL = 'https://www.marketdata.app/docs/sitemap.xml';
const PROD_BASE = '/docs';

const ENVIRONMENTS = {
  staging: { basePath: '/docs-staging' },
  production: { basePath: '/docs' },
};

const TEST_ENV = process.env.TEST_ENV;
const envs = TEST_ENV ? { [TEST_ENV]: ENVIRONMENTS[TEST_ENV] } : ENVIRONMENTS;

// Pages generated by Docusaurus that have no markdown source
const SKIP_SUFFIX_PATTERNS = [
  '/search',
  '/docs/',        // root landing page (auto-generated)
];

const SKIP_CONTAINS = [
  '/tags',              // tag listing pages
];

// Pages with no markdown source — auto-generated or mapped to unexpected paths
// See: https://github.com/MarketDataApp/documentation/issues/127
const SKIP_SUFFIX_EXACT = [
  '/',                  // root page source is at docs/index.md, outside doc plugin paths
  '/sdk/stocks',        // broken category URLs (should be /sdk/go/stocks, etc.)
  '/sdk/markets',
  '/sdk/options',
];

function shouldSkip(path, basePath) {
  if (SKIP_SUFFIX_EXACT.some((suffix) => path === `${basePath}${suffix}`)) return true;
  if (SKIP_SUFFIX_PATTERNS.some((suffix) => path.startsWith(`${basePath}${suffix}`))) return true;
  return SKIP_CONTAINS.some((pattern) => path.includes(pattern));
}

async function fetchSitemapUrls() {
  const res = await fetch(PROD_SITEMAP_URL);
  const xml = await res.text();
  const urls = [];
  for (const match of xml.matchAll(/<loc>([^<]+)<\/loc>/g)) {
    urls.push(new URL(match[1]).pathname);
  }
  return urls;
}

/** Rewrite a production path to the target environment's base path. */
function rebasePath(prodPath, targetBasePath) {
  return prodPath.replace(PROD_BASE, targetBasePath);
}

for (const [env, { basePath }] of Object.entries(envs)) {
  describe(`markdown serving — ${env} (live sitemap)`, async () => {
    const prodPaths = await fetchSitemapUrls();
    const targetPaths = prodPaths
      .map((p) => rebasePath(p, basePath))
      .filter((p) => !shouldSkip(p, basePath));

    it(`sitemap has URLs to test`, () => {
      expect(targetPaths.length).toBeGreaterThan(50);
    });

    for (const path of targetPaths) {
      it(`${path} returns markdown`, async () => {
        const url = `https://www.marketdata.app${path}`;
        const res = await fetch(url, {
          headers: { Accept: 'text/markdown' },
          redirect: 'follow',
        });

        expect(res.status, `${path} returned ${res.status}`).toBe(200);
        expect(res.headers.get('content-type')).toContain('text/markdown');

        const text = await res.text();
        expect(text.length, `${path} returned empty body`).toBeGreaterThan(0);

        // Should not contain raw frontmatter
        expect(text.startsWith('---\n'), `${path} still has frontmatter`).toBe(false);

        // Should not contain MDX import statements
        expect(text, `${path} still has import statements`).not.toMatch(/^import\s+\w+\s+from\s+"/m);

        // Should not contain raw JSX tags from Docusaurus components
        expect(text, `${path} still has <Tabs>`).not.toContain('<Tabs>');
        expect(text, `${path} still has <TabItem`).not.toMatch(/<TabItem\s/);
      });
    }
  });
}
